Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> body_programm
Rule 2     start -> function_declaration_list body_programm
Rule 3     function_declaration_list -> function
Rule 4     function_declaration_list -> function_declaration_list function
Rule 5     body_programm -> identifier_list compound_statement
Rule 6     identifier_list -> identifier
Rule 7     identifier_list -> identifier_list ; identifier
Rule 8     identifier -> type declaration_list
Rule 9     type -> INT
Rule 10    type -> FLOAT
Rule 11    type -> STRING
Rule 12    declaration_list -> IDENTIFIER
Rule 13    declaration_list -> declaration_list , IDENTIFIER
Rule 14    function -> FUNCTION IDENTIFIER ( identifier_list ) { function_statement_list }
Rule 15    function -> FUNCTION IDENTIFIER ( identifier_list ) { identifier_list function_statement_list }
Rule 16    function_calling -> IDENTIFIER ( arguments )
Rule 17    arguments -> argument
Rule 18    arguments -> arguments , argument
Rule 19    argument -> IDENTIFIER
Rule 20    argument -> INT_N
Rule 21    argument -> FLOAT_N
Rule 22    argument -> ( expression )
Rule 23    compound_statement -> { statement_list }
Rule 24    statement_list -> statement
Rule 25    statement_list -> statement_list ; statement
Rule 26    statement -> assigment_statement
Rule 27    statement -> print_statement
Rule 28    statement -> while_statement
Rule 29    statement -> if_statement
Rule 30    statement_list_if -> statement_if
Rule 31    statement_list_if -> statement_list_if ; statement_if
Rule 32    statement_if -> if_statement
Rule 33    statement_if -> assigment_statement
Rule 34    statement_if -> print_statement
Rule 35    statement_if -> while_statement
Rule 36    statement_if -> CONTINUE
Rule 37    statement_if -> BREAK
Rule 38    function_statement_list -> function_statement
Rule 39    function_statement_list -> function_statement_list ; function_statement
Rule 40    function_statement -> if_statement
Rule 41    function_statement -> assigment_statement
Rule 42    function_statement -> print_statement
Rule 43    function_statement -> while_statement
Rule 44    function_statement -> return_statement
Rule 45    return_statement -> RETURN expression
Rule 46    assigment_statement -> IDENTIFIER = expression
Rule 47    assigment_statement -> IDENTIFIER = STRING_LITERAL
Rule 48    expression -> multiplication
Rule 49    expression -> expression + multiplication
Rule 50    expression -> expression - multiplication
Rule 51    multiplication -> item
Rule 52    multiplication -> multiplication * item
Rule 53    multiplication -> multiplication / item
Rule 54    item -> function_calling
Rule 55    item -> IDENTIFIER
Rule 56    item -> INT_N
Rule 57    item -> FLOAT_N
Rule 58    item -> ( expression )
Rule 59    print_statement -> PRINT ( expression )
Rule 60    print_statement -> PRINT ( STRING_LITERAL )
Rule 61    if_statement -> IF logical_expression { statement_list_if }
Rule 62    while_statement -> WHILE logical_expression { statement_list }
Rule 63    logical_expression -> logical_or_expression
Rule 64    logical_expression -> ! logical_or_expression
Rule 65    logical_or_expression -> logical_and_expression
Rule 66    logical_or_expression -> logical_or_expression | logical_and_expression
Rule 67    logical_and_expression -> logical_and_expression & boolean
Rule 68    logical_and_expression -> boolean
Rule 69    boolean -> ( expression EQ_OP expression )
Rule 70    boolean -> ( expression > expression )
Rule 71    boolean -> ( expression < expression )

Terminals, with rules where they appear

!                    : 64
&                    : 67
(                    : 14 15 16 22 58 59 60 69 70 71
)                    : 14 15 16 22 58 59 60 69 70 71
*                    : 52
+                    : 49
,                    : 13 18
-                    : 50
/                    : 53
;                    : 7 25 31 39
<                    : 71
=                    : 46 47
>                    : 70
BREAK                : 37
CONTINUE             : 36
EQ_OP                : 69
FLOAT                : 10
FLOAT_N              : 21 57
FUNCTION             : 14 15
IDENTIFIER           : 12 13 14 15 16 19 46 47 55
IF                   : 61
INT                  : 9
INT_N                : 20 56
PRINT                : 59 60
RETURN               : 45
STRING               : 11
STRING_LITERAL       : 47 60
WHILE                : 62
error                : 
{                    : 14 15 23 61 62
|                    : 66
}                    : 14 15 23 61 62

Nonterminals, with rules where they appear

argument             : 17 18
arguments            : 16 18
assigment_statement  : 26 33 41
body_programm        : 1 2
boolean              : 67 68
compound_statement   : 5
declaration_list     : 8 13
expression           : 22 45 46 49 50 58 59 69 69 70 70 71 71
function             : 3 4
function_calling     : 54
function_declaration_list : 2 4
function_statement   : 38 39
function_statement_list : 14 15 39
identifier           : 6 7
identifier_list      : 5 7 14 15 15
if_statement         : 29 32 40
item                 : 51 52 53
logical_and_expression : 65 66 67
logical_expression   : 61 62
logical_or_expression : 63 64 66
multiplication       : 48 49 50 52 53
print_statement      : 27 34 42
return_statement     : 44
start                : 0
statement            : 24 25
statement_if         : 30 31
statement_list       : 23 25 62
statement_list_if    : 31 61
type                 : 8
while_statement      : 28 35 43

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . body_programm
    (2) start -> . function_declaration_list body_programm
    (5) body_programm -> . identifier_list compound_statement
    (3) function_declaration_list -> . function
    (4) function_declaration_list -> . function_declaration_list function
    (6) identifier_list -> . identifier
    (7) identifier_list -> . identifier_list ; identifier
    (14) function -> . FUNCTION IDENTIFIER ( identifier_list ) { function_statement_list }
    (15) function -> . FUNCTION IDENTIFIER ( identifier_list ) { identifier_list function_statement_list }
    (8) identifier -> . type declaration_list
    (9) type -> . INT
    (10) type -> . FLOAT
    (11) type -> . STRING

    FUNCTION        shift and go to state 7
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    STRING          shift and go to state 11

    start                          shift and go to state 1
    body_programm                  shift and go to state 2
    function_declaration_list      shift and go to state 3
    identifier_list                shift and go to state 4
    function                       shift and go to state 5
    identifier                     shift and go to state 6
    type                           shift and go to state 8

state 1

    (0) S' -> start .



state 2

    (1) start -> body_programm .

    $end            reduce using rule 1 (start -> body_programm .)


state 3

    (2) start -> function_declaration_list . body_programm
    (4) function_declaration_list -> function_declaration_list . function
    (5) body_programm -> . identifier_list compound_statement
    (14) function -> . FUNCTION IDENTIFIER ( identifier_list ) { function_statement_list }
    (15) function -> . FUNCTION IDENTIFIER ( identifier_list ) { identifier_list function_statement_list }
    (6) identifier_list -> . identifier
    (7) identifier_list -> . identifier_list ; identifier
    (8) identifier -> . type declaration_list
    (9) type -> . INT
    (10) type -> . FLOAT
    (11) type -> . STRING

    FUNCTION        shift and go to state 7
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    STRING          shift and go to state 11

    body_programm                  shift and go to state 12
    function                       shift and go to state 13
    identifier_list                shift and go to state 4
    identifier                     shift and go to state 6
    type                           shift and go to state 8

state 4

    (5) body_programm -> identifier_list . compound_statement
    (7) identifier_list -> identifier_list . ; identifier
    (23) compound_statement -> . { statement_list }

    ;               shift and go to state 15
    {               shift and go to state 16

    compound_statement             shift and go to state 14

state 5

    (3) function_declaration_list -> function .

    FUNCTION        reduce using rule 3 (function_declaration_list -> function .)
    INT             reduce using rule 3 (function_declaration_list -> function .)
    FLOAT           reduce using rule 3 (function_declaration_list -> function .)
    STRING          reduce using rule 3 (function_declaration_list -> function .)


state 6

    (6) identifier_list -> identifier .

    ;               reduce using rule 6 (identifier_list -> identifier .)
    {               reduce using rule 6 (identifier_list -> identifier .)
    )               reduce using rule 6 (identifier_list -> identifier .)
    IF              reduce using rule 6 (identifier_list -> identifier .)
    IDENTIFIER      reduce using rule 6 (identifier_list -> identifier .)
    PRINT           reduce using rule 6 (identifier_list -> identifier .)
    WHILE           reduce using rule 6 (identifier_list -> identifier .)
    RETURN          reduce using rule 6 (identifier_list -> identifier .)


state 7

    (14) function -> FUNCTION . IDENTIFIER ( identifier_list ) { function_statement_list }
    (15) function -> FUNCTION . IDENTIFIER ( identifier_list ) { identifier_list function_statement_list }

    IDENTIFIER      shift and go to state 17


state 8

    (8) identifier -> type . declaration_list
    (12) declaration_list -> . IDENTIFIER
    (13) declaration_list -> . declaration_list , IDENTIFIER

    IDENTIFIER      shift and go to state 19

    declaration_list               shift and go to state 18

state 9

    (9) type -> INT .

    IDENTIFIER      reduce using rule 9 (type -> INT .)


state 10

    (10) type -> FLOAT .

    IDENTIFIER      reduce using rule 10 (type -> FLOAT .)


state 11

    (11) type -> STRING .

    IDENTIFIER      reduce using rule 11 (type -> STRING .)


state 12

    (2) start -> function_declaration_list body_programm .

    $end            reduce using rule 2 (start -> function_declaration_list body_programm .)


state 13

    (4) function_declaration_list -> function_declaration_list function .

    FUNCTION        reduce using rule 4 (function_declaration_list -> function_declaration_list function .)
    INT             reduce using rule 4 (function_declaration_list -> function_declaration_list function .)
    FLOAT           reduce using rule 4 (function_declaration_list -> function_declaration_list function .)
    STRING          reduce using rule 4 (function_declaration_list -> function_declaration_list function .)


state 14

    (5) body_programm -> identifier_list compound_statement .

    $end            reduce using rule 5 (body_programm -> identifier_list compound_statement .)


state 15

    (7) identifier_list -> identifier_list ; . identifier
    (8) identifier -> . type declaration_list
    (9) type -> . INT
    (10) type -> . FLOAT
    (11) type -> . STRING

    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    STRING          shift and go to state 11

    identifier                     shift and go to state 20
    type                           shift and go to state 8

state 16

    (23) compound_statement -> { . statement_list }
    (24) statement_list -> . statement
    (25) statement_list -> . statement_list ; statement
    (26) statement -> . assigment_statement
    (27) statement -> . print_statement
    (28) statement -> . while_statement
    (29) statement -> . if_statement
    (46) assigment_statement -> . IDENTIFIER = expression
    (47) assigment_statement -> . IDENTIFIER = STRING_LITERAL
    (59) print_statement -> . PRINT ( expression )
    (60) print_statement -> . PRINT ( STRING_LITERAL )
    (62) while_statement -> . WHILE logical_expression { statement_list }
    (61) if_statement -> . IF logical_expression { statement_list_if }

    IDENTIFIER      shift and go to state 27
    PRINT           shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30

    statement_list                 shift and go to state 21
    statement                      shift and go to state 22
    assigment_statement            shift and go to state 23
    print_statement                shift and go to state 24
    while_statement                shift and go to state 25
    if_statement                   shift and go to state 26

state 17

    (14) function -> FUNCTION IDENTIFIER . ( identifier_list ) { function_statement_list }
    (15) function -> FUNCTION IDENTIFIER . ( identifier_list ) { identifier_list function_statement_list }

    (               shift and go to state 31


state 18

    (8) identifier -> type declaration_list .
    (13) declaration_list -> declaration_list . , IDENTIFIER

    ;               reduce using rule 8 (identifier -> type declaration_list .)
    {               reduce using rule 8 (identifier -> type declaration_list .)
    )               reduce using rule 8 (identifier -> type declaration_list .)
    IF              reduce using rule 8 (identifier -> type declaration_list .)
    IDENTIFIER      reduce using rule 8 (identifier -> type declaration_list .)
    PRINT           reduce using rule 8 (identifier -> type declaration_list .)
    WHILE           reduce using rule 8 (identifier -> type declaration_list .)
    RETURN          reduce using rule 8 (identifier -> type declaration_list .)
    ,               shift and go to state 32


state 19

    (12) declaration_list -> IDENTIFIER .

    ,               reduce using rule 12 (declaration_list -> IDENTIFIER .)
    ;               reduce using rule 12 (declaration_list -> IDENTIFIER .)
    {               reduce using rule 12 (declaration_list -> IDENTIFIER .)
    )               reduce using rule 12 (declaration_list -> IDENTIFIER .)
    IF              reduce using rule 12 (declaration_list -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 12 (declaration_list -> IDENTIFIER .)
    PRINT           reduce using rule 12 (declaration_list -> IDENTIFIER .)
    WHILE           reduce using rule 12 (declaration_list -> IDENTIFIER .)
    RETURN          reduce using rule 12 (declaration_list -> IDENTIFIER .)


state 20

    (7) identifier_list -> identifier_list ; identifier .

    ;               reduce using rule 7 (identifier_list -> identifier_list ; identifier .)
    {               reduce using rule 7 (identifier_list -> identifier_list ; identifier .)
    )               reduce using rule 7 (identifier_list -> identifier_list ; identifier .)
    IF              reduce using rule 7 (identifier_list -> identifier_list ; identifier .)
    IDENTIFIER      reduce using rule 7 (identifier_list -> identifier_list ; identifier .)
    PRINT           reduce using rule 7 (identifier_list -> identifier_list ; identifier .)
    WHILE           reduce using rule 7 (identifier_list -> identifier_list ; identifier .)
    RETURN          reduce using rule 7 (identifier_list -> identifier_list ; identifier .)


state 21

    (23) compound_statement -> { statement_list . }
    (25) statement_list -> statement_list . ; statement

    }               shift and go to state 33
    ;               shift and go to state 34


state 22

    (24) statement_list -> statement .

    }               reduce using rule 24 (statement_list -> statement .)
    ;               reduce using rule 24 (statement_list -> statement .)


state 23

    (26) statement -> assigment_statement .

    }               reduce using rule 26 (statement -> assigment_statement .)
    ;               reduce using rule 26 (statement -> assigment_statement .)


state 24

    (27) statement -> print_statement .

    }               reduce using rule 27 (statement -> print_statement .)
    ;               reduce using rule 27 (statement -> print_statement .)


state 25

    (28) statement -> while_statement .

    }               reduce using rule 28 (statement -> while_statement .)
    ;               reduce using rule 28 (statement -> while_statement .)


state 26

    (29) statement -> if_statement .

    }               reduce using rule 29 (statement -> if_statement .)
    ;               reduce using rule 29 (statement -> if_statement .)


state 27

    (46) assigment_statement -> IDENTIFIER . = expression
    (47) assigment_statement -> IDENTIFIER . = STRING_LITERAL

    =               shift and go to state 35


state 28

    (59) print_statement -> PRINT . ( expression )
    (60) print_statement -> PRINT . ( STRING_LITERAL )

    (               shift and go to state 36


state 29

    (62) while_statement -> WHILE . logical_expression { statement_list }
    (63) logical_expression -> . logical_or_expression
    (64) logical_expression -> . ! logical_or_expression
    (65) logical_or_expression -> . logical_and_expression
    (66) logical_or_expression -> . logical_or_expression | logical_and_expression
    (67) logical_and_expression -> . logical_and_expression & boolean
    (68) logical_and_expression -> . boolean
    (69) boolean -> . ( expression EQ_OP expression )
    (70) boolean -> . ( expression > expression )
    (71) boolean -> . ( expression < expression )

    !               shift and go to state 39
    (               shift and go to state 42

    logical_expression             shift and go to state 37
    logical_or_expression          shift and go to state 38
    logical_and_expression         shift and go to state 40
    boolean                        shift and go to state 41

state 30

    (61) if_statement -> IF . logical_expression { statement_list_if }
    (63) logical_expression -> . logical_or_expression
    (64) logical_expression -> . ! logical_or_expression
    (65) logical_or_expression -> . logical_and_expression
    (66) logical_or_expression -> . logical_or_expression | logical_and_expression
    (67) logical_and_expression -> . logical_and_expression & boolean
    (68) logical_and_expression -> . boolean
    (69) boolean -> . ( expression EQ_OP expression )
    (70) boolean -> . ( expression > expression )
    (71) boolean -> . ( expression < expression )

    !               shift and go to state 39
    (               shift and go to state 42

    logical_expression             shift and go to state 43
    logical_or_expression          shift and go to state 38
    logical_and_expression         shift and go to state 40
    boolean                        shift and go to state 41

state 31

    (14) function -> FUNCTION IDENTIFIER ( . identifier_list ) { function_statement_list }
    (15) function -> FUNCTION IDENTIFIER ( . identifier_list ) { identifier_list function_statement_list }
    (6) identifier_list -> . identifier
    (7) identifier_list -> . identifier_list ; identifier
    (8) identifier -> . type declaration_list
    (9) type -> . INT
    (10) type -> . FLOAT
    (11) type -> . STRING

    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    STRING          shift and go to state 11

    identifier_list                shift and go to state 44
    identifier                     shift and go to state 6
    type                           shift and go to state 8

state 32

    (13) declaration_list -> declaration_list , . IDENTIFIER

    IDENTIFIER      shift and go to state 45


state 33

    (23) compound_statement -> { statement_list } .

    $end            reduce using rule 23 (compound_statement -> { statement_list } .)


state 34

    (25) statement_list -> statement_list ; . statement
    (26) statement -> . assigment_statement
    (27) statement -> . print_statement
    (28) statement -> . while_statement
    (29) statement -> . if_statement
    (46) assigment_statement -> . IDENTIFIER = expression
    (47) assigment_statement -> . IDENTIFIER = STRING_LITERAL
    (59) print_statement -> . PRINT ( expression )
    (60) print_statement -> . PRINT ( STRING_LITERAL )
    (62) while_statement -> . WHILE logical_expression { statement_list }
    (61) if_statement -> . IF logical_expression { statement_list_if }

    IDENTIFIER      shift and go to state 27
    PRINT           shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30

    statement                      shift and go to state 46
    assigment_statement            shift and go to state 23
    print_statement                shift and go to state 24
    while_statement                shift and go to state 25
    if_statement                   shift and go to state 26

state 35

    (46) assigment_statement -> IDENTIFIER = . expression
    (47) assigment_statement -> IDENTIFIER = . STRING_LITERAL
    (48) expression -> . multiplication
    (49) expression -> . expression + multiplication
    (50) expression -> . expression - multiplication
    (51) multiplication -> . item
    (52) multiplication -> . multiplication * item
    (53) multiplication -> . multiplication / item
    (54) item -> . function_calling
    (55) item -> . IDENTIFIER
    (56) item -> . INT_N
    (57) item -> . FLOAT_N
    (58) item -> . ( expression )
    (16) function_calling -> . IDENTIFIER ( arguments )

    STRING_LITERAL  shift and go to state 49
    IDENTIFIER      shift and go to state 47
    INT_N           shift and go to state 53
    FLOAT_N         shift and go to state 54
    (               shift and go to state 55

    expression                     shift and go to state 48
    multiplication                 shift and go to state 50
    item                           shift and go to state 51
    function_calling               shift and go to state 52

state 36

    (59) print_statement -> PRINT ( . expression )
    (60) print_statement -> PRINT ( . STRING_LITERAL )
    (48) expression -> . multiplication
    (49) expression -> . expression + multiplication
    (50) expression -> . expression - multiplication
    (51) multiplication -> . item
    (52) multiplication -> . multiplication * item
    (53) multiplication -> . multiplication / item
    (54) item -> . function_calling
    (55) item -> . IDENTIFIER
    (56) item -> . INT_N
    (57) item -> . FLOAT_N
    (58) item -> . ( expression )
    (16) function_calling -> . IDENTIFIER ( arguments )

    STRING_LITERAL  shift and go to state 57
    IDENTIFIER      shift and go to state 47
    INT_N           shift and go to state 53
    FLOAT_N         shift and go to state 54
    (               shift and go to state 55

    expression                     shift and go to state 56
    multiplication                 shift and go to state 50
    item                           shift and go to state 51
    function_calling               shift and go to state 52

state 37

    (62) while_statement -> WHILE logical_expression . { statement_list }

    {               shift and go to state 58


state 38

    (63) logical_expression -> logical_or_expression .
    (66) logical_or_expression -> logical_or_expression . | logical_and_expression

    {               reduce using rule 63 (logical_expression -> logical_or_expression .)
    |               shift and go to state 59


state 39

    (64) logical_expression -> ! . logical_or_expression
    (65) logical_or_expression -> . logical_and_expression
    (66) logical_or_expression -> . logical_or_expression | logical_and_expression
    (67) logical_and_expression -> . logical_and_expression & boolean
    (68) logical_and_expression -> . boolean
    (69) boolean -> . ( expression EQ_OP expression )
    (70) boolean -> . ( expression > expression )
    (71) boolean -> . ( expression < expression )

    (               shift and go to state 42

    logical_or_expression          shift and go to state 60
    logical_and_expression         shift and go to state 40
    boolean                        shift and go to state 41

state 40

    (65) logical_or_expression -> logical_and_expression .
    (67) logical_and_expression -> logical_and_expression . & boolean

    |               reduce using rule 65 (logical_or_expression -> logical_and_expression .)
    {               reduce using rule 65 (logical_or_expression -> logical_and_expression .)
    &               shift and go to state 61


state 41

    (68) logical_and_expression -> boolean .

    &               reduce using rule 68 (logical_and_expression -> boolean .)
    |               reduce using rule 68 (logical_and_expression -> boolean .)
    {               reduce using rule 68 (logical_and_expression -> boolean .)


state 42

    (69) boolean -> ( . expression EQ_OP expression )
    (70) boolean -> ( . expression > expression )
    (71) boolean -> ( . expression < expression )
    (48) expression -> . multiplication
    (49) expression -> . expression + multiplication
    (50) expression -> . expression - multiplication
    (51) multiplication -> . item
    (52) multiplication -> . multiplication * item
    (53) multiplication -> . multiplication / item
    (54) item -> . function_calling
    (55) item -> . IDENTIFIER
    (56) item -> . INT_N
    (57) item -> . FLOAT_N
    (58) item -> . ( expression )
    (16) function_calling -> . IDENTIFIER ( arguments )

    IDENTIFIER      shift and go to state 47
    INT_N           shift and go to state 53
    FLOAT_N         shift and go to state 54
    (               shift and go to state 55

    expression                     shift and go to state 62
    multiplication                 shift and go to state 50
    item                           shift and go to state 51
    function_calling               shift and go to state 52

state 43

    (61) if_statement -> IF logical_expression . { statement_list_if }

    {               shift and go to state 63


state 44

    (14) function -> FUNCTION IDENTIFIER ( identifier_list . ) { function_statement_list }
    (15) function -> FUNCTION IDENTIFIER ( identifier_list . ) { identifier_list function_statement_list }
    (7) identifier_list -> identifier_list . ; identifier

    )               shift and go to state 64
    ;               shift and go to state 15


state 45

    (13) declaration_list -> declaration_list , IDENTIFIER .

    ,               reduce using rule 13 (declaration_list -> declaration_list , IDENTIFIER .)
    ;               reduce using rule 13 (declaration_list -> declaration_list , IDENTIFIER .)
    {               reduce using rule 13 (declaration_list -> declaration_list , IDENTIFIER .)
    )               reduce using rule 13 (declaration_list -> declaration_list , IDENTIFIER .)
    IF              reduce using rule 13 (declaration_list -> declaration_list , IDENTIFIER .)
    IDENTIFIER      reduce using rule 13 (declaration_list -> declaration_list , IDENTIFIER .)
    PRINT           reduce using rule 13 (declaration_list -> declaration_list , IDENTIFIER .)
    WHILE           reduce using rule 13 (declaration_list -> declaration_list , IDENTIFIER .)
    RETURN          reduce using rule 13 (declaration_list -> declaration_list , IDENTIFIER .)


state 46

    (25) statement_list -> statement_list ; statement .

    }               reduce using rule 25 (statement_list -> statement_list ; statement .)
    ;               reduce using rule 25 (statement_list -> statement_list ; statement .)


state 47

    (55) item -> IDENTIFIER .
    (16) function_calling -> IDENTIFIER . ( arguments )

    *               reduce using rule 55 (item -> IDENTIFIER .)
    /               reduce using rule 55 (item -> IDENTIFIER .)
    +               reduce using rule 55 (item -> IDENTIFIER .)
    -               reduce using rule 55 (item -> IDENTIFIER .)
    }               reduce using rule 55 (item -> IDENTIFIER .)
    ;               reduce using rule 55 (item -> IDENTIFIER .)
    )               reduce using rule 55 (item -> IDENTIFIER .)
    EQ_OP           reduce using rule 55 (item -> IDENTIFIER .)
    >               reduce using rule 55 (item -> IDENTIFIER .)
    <               reduce using rule 55 (item -> IDENTIFIER .)
    (               shift and go to state 65


state 48

    (46) assigment_statement -> IDENTIFIER = expression .
    (49) expression -> expression . + multiplication
    (50) expression -> expression . - multiplication

    }               reduce using rule 46 (assigment_statement -> IDENTIFIER = expression .)
    ;               reduce using rule 46 (assigment_statement -> IDENTIFIER = expression .)
    +               shift and go to state 66
    -               shift and go to state 67


state 49

    (47) assigment_statement -> IDENTIFIER = STRING_LITERAL .

    }               reduce using rule 47 (assigment_statement -> IDENTIFIER = STRING_LITERAL .)
    ;               reduce using rule 47 (assigment_statement -> IDENTIFIER = STRING_LITERAL .)


state 50

    (48) expression -> multiplication .
    (52) multiplication -> multiplication . * item
    (53) multiplication -> multiplication . / item

    +               reduce using rule 48 (expression -> multiplication .)
    -               reduce using rule 48 (expression -> multiplication .)
    }               reduce using rule 48 (expression -> multiplication .)
    ;               reduce using rule 48 (expression -> multiplication .)
    )               reduce using rule 48 (expression -> multiplication .)
    EQ_OP           reduce using rule 48 (expression -> multiplication .)
    >               reduce using rule 48 (expression -> multiplication .)
    <               reduce using rule 48 (expression -> multiplication .)
    *               shift and go to state 68
    /               shift and go to state 69


state 51

    (51) multiplication -> item .

    *               reduce using rule 51 (multiplication -> item .)
    /               reduce using rule 51 (multiplication -> item .)
    +               reduce using rule 51 (multiplication -> item .)
    -               reduce using rule 51 (multiplication -> item .)
    }               reduce using rule 51 (multiplication -> item .)
    ;               reduce using rule 51 (multiplication -> item .)
    )               reduce using rule 51 (multiplication -> item .)
    EQ_OP           reduce using rule 51 (multiplication -> item .)
    >               reduce using rule 51 (multiplication -> item .)
    <               reduce using rule 51 (multiplication -> item .)


state 52

    (54) item -> function_calling .

    *               reduce using rule 54 (item -> function_calling .)
    /               reduce using rule 54 (item -> function_calling .)
    +               reduce using rule 54 (item -> function_calling .)
    -               reduce using rule 54 (item -> function_calling .)
    }               reduce using rule 54 (item -> function_calling .)
    ;               reduce using rule 54 (item -> function_calling .)
    )               reduce using rule 54 (item -> function_calling .)
    EQ_OP           reduce using rule 54 (item -> function_calling .)
    >               reduce using rule 54 (item -> function_calling .)
    <               reduce using rule 54 (item -> function_calling .)


state 53

    (56) item -> INT_N .

    *               reduce using rule 56 (item -> INT_N .)
    /               reduce using rule 56 (item -> INT_N .)
    +               reduce using rule 56 (item -> INT_N .)
    -               reduce using rule 56 (item -> INT_N .)
    }               reduce using rule 56 (item -> INT_N .)
    ;               reduce using rule 56 (item -> INT_N .)
    )               reduce using rule 56 (item -> INT_N .)
    EQ_OP           reduce using rule 56 (item -> INT_N .)
    >               reduce using rule 56 (item -> INT_N .)
    <               reduce using rule 56 (item -> INT_N .)


state 54

    (57) item -> FLOAT_N .

    *               reduce using rule 57 (item -> FLOAT_N .)
    /               reduce using rule 57 (item -> FLOAT_N .)
    +               reduce using rule 57 (item -> FLOAT_N .)
    -               reduce using rule 57 (item -> FLOAT_N .)
    }               reduce using rule 57 (item -> FLOAT_N .)
    ;               reduce using rule 57 (item -> FLOAT_N .)
    )               reduce using rule 57 (item -> FLOAT_N .)
    EQ_OP           reduce using rule 57 (item -> FLOAT_N .)
    >               reduce using rule 57 (item -> FLOAT_N .)
    <               reduce using rule 57 (item -> FLOAT_N .)


state 55

    (58) item -> ( . expression )
    (48) expression -> . multiplication
    (49) expression -> . expression + multiplication
    (50) expression -> . expression - multiplication
    (51) multiplication -> . item
    (52) multiplication -> . multiplication * item
    (53) multiplication -> . multiplication / item
    (54) item -> . function_calling
    (55) item -> . IDENTIFIER
    (56) item -> . INT_N
    (57) item -> . FLOAT_N
    (58) item -> . ( expression )
    (16) function_calling -> . IDENTIFIER ( arguments )

    IDENTIFIER      shift and go to state 47
    INT_N           shift and go to state 53
    FLOAT_N         shift and go to state 54
    (               shift and go to state 55

    expression                     shift and go to state 70
    multiplication                 shift and go to state 50
    item                           shift and go to state 51
    function_calling               shift and go to state 52

state 56

    (59) print_statement -> PRINT ( expression . )
    (49) expression -> expression . + multiplication
    (50) expression -> expression . - multiplication

    )               shift and go to state 71
    +               shift and go to state 66
    -               shift and go to state 67


state 57

    (60) print_statement -> PRINT ( STRING_LITERAL . )

    )               shift and go to state 72


state 58

    (62) while_statement -> WHILE logical_expression { . statement_list }
    (24) statement_list -> . statement
    (25) statement_list -> . statement_list ; statement
    (26) statement -> . assigment_statement
    (27) statement -> . print_statement
    (28) statement -> . while_statement
    (29) statement -> . if_statement
    (46) assigment_statement -> . IDENTIFIER = expression
    (47) assigment_statement -> . IDENTIFIER = STRING_LITERAL
    (59) print_statement -> . PRINT ( expression )
    (60) print_statement -> . PRINT ( STRING_LITERAL )
    (62) while_statement -> . WHILE logical_expression { statement_list }
    (61) if_statement -> . IF logical_expression { statement_list_if }

    IDENTIFIER      shift and go to state 27
    PRINT           shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30

    statement_list                 shift and go to state 73
    statement                      shift and go to state 22
    assigment_statement            shift and go to state 23
    print_statement                shift and go to state 24
    while_statement                shift and go to state 25
    if_statement                   shift and go to state 26

state 59

    (66) logical_or_expression -> logical_or_expression | . logical_and_expression
    (67) logical_and_expression -> . logical_and_expression & boolean
    (68) logical_and_expression -> . boolean
    (69) boolean -> . ( expression EQ_OP expression )
    (70) boolean -> . ( expression > expression )
    (71) boolean -> . ( expression < expression )

    (               shift and go to state 42

    logical_and_expression         shift and go to state 74
    boolean                        shift and go to state 41

state 60

    (64) logical_expression -> ! logical_or_expression .
    (66) logical_or_expression -> logical_or_expression . | logical_and_expression

    {               reduce using rule 64 (logical_expression -> ! logical_or_expression .)
    |               shift and go to state 59


state 61

    (67) logical_and_expression -> logical_and_expression & . boolean
    (69) boolean -> . ( expression EQ_OP expression )
    (70) boolean -> . ( expression > expression )
    (71) boolean -> . ( expression < expression )

    (               shift and go to state 42

    boolean                        shift and go to state 75

state 62

    (69) boolean -> ( expression . EQ_OP expression )
    (70) boolean -> ( expression . > expression )
    (71) boolean -> ( expression . < expression )
    (49) expression -> expression . + multiplication
    (50) expression -> expression . - multiplication

    EQ_OP           shift and go to state 76
    >               shift and go to state 77
    <               shift and go to state 78
    +               shift and go to state 66
    -               shift and go to state 67


state 63

    (61) if_statement -> IF logical_expression { . statement_list_if }
    (30) statement_list_if -> . statement_if
    (31) statement_list_if -> . statement_list_if ; statement_if
    (32) statement_if -> . if_statement
    (33) statement_if -> . assigment_statement
    (34) statement_if -> . print_statement
    (35) statement_if -> . while_statement
    (36) statement_if -> . CONTINUE
    (37) statement_if -> . BREAK
    (61) if_statement -> . IF logical_expression { statement_list_if }
    (46) assigment_statement -> . IDENTIFIER = expression
    (47) assigment_statement -> . IDENTIFIER = STRING_LITERAL
    (59) print_statement -> . PRINT ( expression )
    (60) print_statement -> . PRINT ( STRING_LITERAL )
    (62) while_statement -> . WHILE logical_expression { statement_list }

    CONTINUE        shift and go to state 85
    BREAK           shift and go to state 86
    IF              shift and go to state 30
    IDENTIFIER      shift and go to state 27
    PRINT           shift and go to state 28
    WHILE           shift and go to state 29

    statement_list_if              shift and go to state 79
    statement_if                   shift and go to state 80
    if_statement                   shift and go to state 81
    assigment_statement            shift and go to state 82
    print_statement                shift and go to state 83
    while_statement                shift and go to state 84

state 64

    (14) function -> FUNCTION IDENTIFIER ( identifier_list ) . { function_statement_list }
    (15) function -> FUNCTION IDENTIFIER ( identifier_list ) . { identifier_list function_statement_list }

    {               shift and go to state 87


state 65

    (16) function_calling -> IDENTIFIER ( . arguments )
    (17) arguments -> . argument
    (18) arguments -> . arguments , argument
    (19) argument -> . IDENTIFIER
    (20) argument -> . INT_N
    (21) argument -> . FLOAT_N
    (22) argument -> . ( expression )

    IDENTIFIER      shift and go to state 88
    INT_N           shift and go to state 92
    FLOAT_N         shift and go to state 93
    (               shift and go to state 89

    arguments                      shift and go to state 90
    argument                       shift and go to state 91

state 66

    (49) expression -> expression + . multiplication
    (51) multiplication -> . item
    (52) multiplication -> . multiplication * item
    (53) multiplication -> . multiplication / item
    (54) item -> . function_calling
    (55) item -> . IDENTIFIER
    (56) item -> . INT_N
    (57) item -> . FLOAT_N
    (58) item -> . ( expression )
    (16) function_calling -> . IDENTIFIER ( arguments )

    IDENTIFIER      shift and go to state 47
    INT_N           shift and go to state 53
    FLOAT_N         shift and go to state 54
    (               shift and go to state 55

    multiplication                 shift and go to state 94
    item                           shift and go to state 51
    function_calling               shift and go to state 52

state 67

    (50) expression -> expression - . multiplication
    (51) multiplication -> . item
    (52) multiplication -> . multiplication * item
    (53) multiplication -> . multiplication / item
    (54) item -> . function_calling
    (55) item -> . IDENTIFIER
    (56) item -> . INT_N
    (57) item -> . FLOAT_N
    (58) item -> . ( expression )
    (16) function_calling -> . IDENTIFIER ( arguments )

    IDENTIFIER      shift and go to state 47
    INT_N           shift and go to state 53
    FLOAT_N         shift and go to state 54
    (               shift and go to state 55

    multiplication                 shift and go to state 95
    item                           shift and go to state 51
    function_calling               shift and go to state 52

state 68

    (52) multiplication -> multiplication * . item
    (54) item -> . function_calling
    (55) item -> . IDENTIFIER
    (56) item -> . INT_N
    (57) item -> . FLOAT_N
    (58) item -> . ( expression )
    (16) function_calling -> . IDENTIFIER ( arguments )

    IDENTIFIER      shift and go to state 47
    INT_N           shift and go to state 53
    FLOAT_N         shift and go to state 54
    (               shift and go to state 55

    item                           shift and go to state 96
    function_calling               shift and go to state 52

state 69

    (53) multiplication -> multiplication / . item
    (54) item -> . function_calling
    (55) item -> . IDENTIFIER
    (56) item -> . INT_N
    (57) item -> . FLOAT_N
    (58) item -> . ( expression )
    (16) function_calling -> . IDENTIFIER ( arguments )

    IDENTIFIER      shift and go to state 47
    INT_N           shift and go to state 53
    FLOAT_N         shift and go to state 54
    (               shift and go to state 55

    item                           shift and go to state 97
    function_calling               shift and go to state 52

state 70

    (58) item -> ( expression . )
    (49) expression -> expression . + multiplication
    (50) expression -> expression . - multiplication

    )               shift and go to state 98
    +               shift and go to state 66
    -               shift and go to state 67


state 71

    (59) print_statement -> PRINT ( expression ) .

    }               reduce using rule 59 (print_statement -> PRINT ( expression ) .)
    ;               reduce using rule 59 (print_statement -> PRINT ( expression ) .)


state 72

    (60) print_statement -> PRINT ( STRING_LITERAL ) .

    }               reduce using rule 60 (print_statement -> PRINT ( STRING_LITERAL ) .)
    ;               reduce using rule 60 (print_statement -> PRINT ( STRING_LITERAL ) .)


state 73

    (62) while_statement -> WHILE logical_expression { statement_list . }
    (25) statement_list -> statement_list . ; statement

    }               shift and go to state 99
    ;               shift and go to state 34


state 74

    (66) logical_or_expression -> logical_or_expression | logical_and_expression .
    (67) logical_and_expression -> logical_and_expression . & boolean

    |               reduce using rule 66 (logical_or_expression -> logical_or_expression | logical_and_expression .)
    {               reduce using rule 66 (logical_or_expression -> logical_or_expression | logical_and_expression .)
    &               shift and go to state 61


state 75

    (67) logical_and_expression -> logical_and_expression & boolean .

    &               reduce using rule 67 (logical_and_expression -> logical_and_expression & boolean .)
    |               reduce using rule 67 (logical_and_expression -> logical_and_expression & boolean .)
    {               reduce using rule 67 (logical_and_expression -> logical_and_expression & boolean .)


state 76

    (69) boolean -> ( expression EQ_OP . expression )
    (48) expression -> . multiplication
    (49) expression -> . expression + multiplication
    (50) expression -> . expression - multiplication
    (51) multiplication -> . item
    (52) multiplication -> . multiplication * item
    (53) multiplication -> . multiplication / item
    (54) item -> . function_calling
    (55) item -> . IDENTIFIER
    (56) item -> . INT_N
    (57) item -> . FLOAT_N
    (58) item -> . ( expression )
    (16) function_calling -> . IDENTIFIER ( arguments )

    IDENTIFIER      shift and go to state 47
    INT_N           shift and go to state 53
    FLOAT_N         shift and go to state 54
    (               shift and go to state 55

    expression                     shift and go to state 100
    multiplication                 shift and go to state 50
    item                           shift and go to state 51
    function_calling               shift and go to state 52

state 77

    (70) boolean -> ( expression > . expression )
    (48) expression -> . multiplication
    (49) expression -> . expression + multiplication
    (50) expression -> . expression - multiplication
    (51) multiplication -> . item
    (52) multiplication -> . multiplication * item
    (53) multiplication -> . multiplication / item
    (54) item -> . function_calling
    (55) item -> . IDENTIFIER
    (56) item -> . INT_N
    (57) item -> . FLOAT_N
    (58) item -> . ( expression )
    (16) function_calling -> . IDENTIFIER ( arguments )

    IDENTIFIER      shift and go to state 47
    INT_N           shift and go to state 53
    FLOAT_N         shift and go to state 54
    (               shift and go to state 55

    expression                     shift and go to state 101
    multiplication                 shift and go to state 50
    item                           shift and go to state 51
    function_calling               shift and go to state 52

state 78

    (71) boolean -> ( expression < . expression )
    (48) expression -> . multiplication
    (49) expression -> . expression + multiplication
    (50) expression -> . expression - multiplication
    (51) multiplication -> . item
    (52) multiplication -> . multiplication * item
    (53) multiplication -> . multiplication / item
    (54) item -> . function_calling
    (55) item -> . IDENTIFIER
    (56) item -> . INT_N
    (57) item -> . FLOAT_N
    (58) item -> . ( expression )
    (16) function_calling -> . IDENTIFIER ( arguments )

    IDENTIFIER      shift and go to state 47
    INT_N           shift and go to state 53
    FLOAT_N         shift and go to state 54
    (               shift and go to state 55

    expression                     shift and go to state 102
    multiplication                 shift and go to state 50
    item                           shift and go to state 51
    function_calling               shift and go to state 52

state 79

    (61) if_statement -> IF logical_expression { statement_list_if . }
    (31) statement_list_if -> statement_list_if . ; statement_if

    }               shift and go to state 103
    ;               shift and go to state 104


state 80

    (30) statement_list_if -> statement_if .

    }               reduce using rule 30 (statement_list_if -> statement_if .)
    ;               reduce using rule 30 (statement_list_if -> statement_if .)


state 81

    (32) statement_if -> if_statement .

    }               reduce using rule 32 (statement_if -> if_statement .)
    ;               reduce using rule 32 (statement_if -> if_statement .)


state 82

    (33) statement_if -> assigment_statement .

    }               reduce using rule 33 (statement_if -> assigment_statement .)
    ;               reduce using rule 33 (statement_if -> assigment_statement .)


state 83

    (34) statement_if -> print_statement .

    }               reduce using rule 34 (statement_if -> print_statement .)
    ;               reduce using rule 34 (statement_if -> print_statement .)


state 84

    (35) statement_if -> while_statement .

    }               reduce using rule 35 (statement_if -> while_statement .)
    ;               reduce using rule 35 (statement_if -> while_statement .)


state 85

    (36) statement_if -> CONTINUE .

    }               reduce using rule 36 (statement_if -> CONTINUE .)
    ;               reduce using rule 36 (statement_if -> CONTINUE .)


state 86

    (37) statement_if -> BREAK .

    }               reduce using rule 37 (statement_if -> BREAK .)
    ;               reduce using rule 37 (statement_if -> BREAK .)


state 87

    (14) function -> FUNCTION IDENTIFIER ( identifier_list ) { . function_statement_list }
    (15) function -> FUNCTION IDENTIFIER ( identifier_list ) { . identifier_list function_statement_list }
    (38) function_statement_list -> . function_statement
    (39) function_statement_list -> . function_statement_list ; function_statement
    (6) identifier_list -> . identifier
    (7) identifier_list -> . identifier_list ; identifier
    (40) function_statement -> . if_statement
    (41) function_statement -> . assigment_statement
    (42) function_statement -> . print_statement
    (43) function_statement -> . while_statement
    (44) function_statement -> . return_statement
    (8) identifier -> . type declaration_list
    (61) if_statement -> . IF logical_expression { statement_list_if }
    (46) assigment_statement -> . IDENTIFIER = expression
    (47) assigment_statement -> . IDENTIFIER = STRING_LITERAL
    (59) print_statement -> . PRINT ( expression )
    (60) print_statement -> . PRINT ( STRING_LITERAL )
    (62) while_statement -> . WHILE logical_expression { statement_list }
    (45) return_statement -> . RETURN expression
    (9) type -> . INT
    (10) type -> . FLOAT
    (11) type -> . STRING

    IF              shift and go to state 30
    IDENTIFIER      shift and go to state 27
    PRINT           shift and go to state 28
    WHILE           shift and go to state 29
    RETURN          shift and go to state 113
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    STRING          shift and go to state 11

    identifier_list                shift and go to state 105
    function_statement_list        shift and go to state 106
    function_statement             shift and go to state 107
    identifier                     shift and go to state 6
    if_statement                   shift and go to state 108
    assigment_statement            shift and go to state 109
    print_statement                shift and go to state 110
    while_statement                shift and go to state 111
    return_statement               shift and go to state 112
    type                           shift and go to state 8

state 88

    (19) argument -> IDENTIFIER .

    )               reduce using rule 19 (argument -> IDENTIFIER .)
    ,               reduce using rule 19 (argument -> IDENTIFIER .)


state 89

    (22) argument -> ( . expression )
    (48) expression -> . multiplication
    (49) expression -> . expression + multiplication
    (50) expression -> . expression - multiplication
    (51) multiplication -> . item
    (52) multiplication -> . multiplication * item
    (53) multiplication -> . multiplication / item
    (54) item -> . function_calling
    (55) item -> . IDENTIFIER
    (56) item -> . INT_N
    (57) item -> . FLOAT_N
    (58) item -> . ( expression )
    (16) function_calling -> . IDENTIFIER ( arguments )

    IDENTIFIER      shift and go to state 47
    INT_N           shift and go to state 53
    FLOAT_N         shift and go to state 54
    (               shift and go to state 55

    expression                     shift and go to state 114
    multiplication                 shift and go to state 50
    item                           shift and go to state 51
    function_calling               shift and go to state 52

state 90

    (16) function_calling -> IDENTIFIER ( arguments . )
    (18) arguments -> arguments . , argument

    )               shift and go to state 115
    ,               shift and go to state 116


state 91

    (17) arguments -> argument .

    )               reduce using rule 17 (arguments -> argument .)
    ,               reduce using rule 17 (arguments -> argument .)


state 92

    (20) argument -> INT_N .

    )               reduce using rule 20 (argument -> INT_N .)
    ,               reduce using rule 20 (argument -> INT_N .)


state 93

    (21) argument -> FLOAT_N .

    )               reduce using rule 21 (argument -> FLOAT_N .)
    ,               reduce using rule 21 (argument -> FLOAT_N .)


state 94

    (49) expression -> expression + multiplication .
    (52) multiplication -> multiplication . * item
    (53) multiplication -> multiplication . / item

    +               reduce using rule 49 (expression -> expression + multiplication .)
    -               reduce using rule 49 (expression -> expression + multiplication .)
    }               reduce using rule 49 (expression -> expression + multiplication .)
    ;               reduce using rule 49 (expression -> expression + multiplication .)
    )               reduce using rule 49 (expression -> expression + multiplication .)
    EQ_OP           reduce using rule 49 (expression -> expression + multiplication .)
    >               reduce using rule 49 (expression -> expression + multiplication .)
    <               reduce using rule 49 (expression -> expression + multiplication .)
    *               shift and go to state 68
    /               shift and go to state 69


state 95

    (50) expression -> expression - multiplication .
    (52) multiplication -> multiplication . * item
    (53) multiplication -> multiplication . / item

    +               reduce using rule 50 (expression -> expression - multiplication .)
    -               reduce using rule 50 (expression -> expression - multiplication .)
    }               reduce using rule 50 (expression -> expression - multiplication .)
    ;               reduce using rule 50 (expression -> expression - multiplication .)
    )               reduce using rule 50 (expression -> expression - multiplication .)
    EQ_OP           reduce using rule 50 (expression -> expression - multiplication .)
    >               reduce using rule 50 (expression -> expression - multiplication .)
    <               reduce using rule 50 (expression -> expression - multiplication .)
    *               shift and go to state 68
    /               shift and go to state 69


state 96

    (52) multiplication -> multiplication * item .

    *               reduce using rule 52 (multiplication -> multiplication * item .)
    /               reduce using rule 52 (multiplication -> multiplication * item .)
    +               reduce using rule 52 (multiplication -> multiplication * item .)
    -               reduce using rule 52 (multiplication -> multiplication * item .)
    }               reduce using rule 52 (multiplication -> multiplication * item .)
    ;               reduce using rule 52 (multiplication -> multiplication * item .)
    )               reduce using rule 52 (multiplication -> multiplication * item .)
    EQ_OP           reduce using rule 52 (multiplication -> multiplication * item .)
    >               reduce using rule 52 (multiplication -> multiplication * item .)
    <               reduce using rule 52 (multiplication -> multiplication * item .)


state 97

    (53) multiplication -> multiplication / item .

    *               reduce using rule 53 (multiplication -> multiplication / item .)
    /               reduce using rule 53 (multiplication -> multiplication / item .)
    +               reduce using rule 53 (multiplication -> multiplication / item .)
    -               reduce using rule 53 (multiplication -> multiplication / item .)
    }               reduce using rule 53 (multiplication -> multiplication / item .)
    ;               reduce using rule 53 (multiplication -> multiplication / item .)
    )               reduce using rule 53 (multiplication -> multiplication / item .)
    EQ_OP           reduce using rule 53 (multiplication -> multiplication / item .)
    >               reduce using rule 53 (multiplication -> multiplication / item .)
    <               reduce using rule 53 (multiplication -> multiplication / item .)


state 98

    (58) item -> ( expression ) .

    *               reduce using rule 58 (item -> ( expression ) .)
    /               reduce using rule 58 (item -> ( expression ) .)
    +               reduce using rule 58 (item -> ( expression ) .)
    -               reduce using rule 58 (item -> ( expression ) .)
    }               reduce using rule 58 (item -> ( expression ) .)
    ;               reduce using rule 58 (item -> ( expression ) .)
    )               reduce using rule 58 (item -> ( expression ) .)
    EQ_OP           reduce using rule 58 (item -> ( expression ) .)
    >               reduce using rule 58 (item -> ( expression ) .)
    <               reduce using rule 58 (item -> ( expression ) .)


state 99

    (62) while_statement -> WHILE logical_expression { statement_list } .

    }               reduce using rule 62 (while_statement -> WHILE logical_expression { statement_list } .)
    ;               reduce using rule 62 (while_statement -> WHILE logical_expression { statement_list } .)


state 100

    (69) boolean -> ( expression EQ_OP expression . )
    (49) expression -> expression . + multiplication
    (50) expression -> expression . - multiplication

    )               shift and go to state 117
    +               shift and go to state 66
    -               shift and go to state 67


state 101

    (70) boolean -> ( expression > expression . )
    (49) expression -> expression . + multiplication
    (50) expression -> expression . - multiplication

    )               shift and go to state 118
    +               shift and go to state 66
    -               shift and go to state 67


state 102

    (71) boolean -> ( expression < expression . )
    (49) expression -> expression . + multiplication
    (50) expression -> expression . - multiplication

    )               shift and go to state 119
    +               shift and go to state 66
    -               shift and go to state 67


state 103

    (61) if_statement -> IF logical_expression { statement_list_if } .

    }               reduce using rule 61 (if_statement -> IF logical_expression { statement_list_if } .)
    ;               reduce using rule 61 (if_statement -> IF logical_expression { statement_list_if } .)


state 104

    (31) statement_list_if -> statement_list_if ; . statement_if
    (32) statement_if -> . if_statement
    (33) statement_if -> . assigment_statement
    (34) statement_if -> . print_statement
    (35) statement_if -> . while_statement
    (36) statement_if -> . CONTINUE
    (37) statement_if -> . BREAK
    (61) if_statement -> . IF logical_expression { statement_list_if }
    (46) assigment_statement -> . IDENTIFIER = expression
    (47) assigment_statement -> . IDENTIFIER = STRING_LITERAL
    (59) print_statement -> . PRINT ( expression )
    (60) print_statement -> . PRINT ( STRING_LITERAL )
    (62) while_statement -> . WHILE logical_expression { statement_list }

    CONTINUE        shift and go to state 85
    BREAK           shift and go to state 86
    IF              shift and go to state 30
    IDENTIFIER      shift and go to state 27
    PRINT           shift and go to state 28
    WHILE           shift and go to state 29

    statement_if                   shift and go to state 120
    if_statement                   shift and go to state 81
    assigment_statement            shift and go to state 82
    print_statement                shift and go to state 83
    while_statement                shift and go to state 84

state 105

    (15) function -> FUNCTION IDENTIFIER ( identifier_list ) { identifier_list . function_statement_list }
    (7) identifier_list -> identifier_list . ; identifier
    (38) function_statement_list -> . function_statement
    (39) function_statement_list -> . function_statement_list ; function_statement
    (40) function_statement -> . if_statement
    (41) function_statement -> . assigment_statement
    (42) function_statement -> . print_statement
    (43) function_statement -> . while_statement
    (44) function_statement -> . return_statement
    (61) if_statement -> . IF logical_expression { statement_list_if }
    (46) assigment_statement -> . IDENTIFIER = expression
    (47) assigment_statement -> . IDENTIFIER = STRING_LITERAL
    (59) print_statement -> . PRINT ( expression )
    (60) print_statement -> . PRINT ( STRING_LITERAL )
    (62) while_statement -> . WHILE logical_expression { statement_list }
    (45) return_statement -> . RETURN expression

    ;               shift and go to state 15
    IF              shift and go to state 30
    IDENTIFIER      shift and go to state 27
    PRINT           shift and go to state 28
    WHILE           shift and go to state 29
    RETURN          shift and go to state 113

    function_statement_list        shift and go to state 121
    function_statement             shift and go to state 107
    if_statement                   shift and go to state 108
    assigment_statement            shift and go to state 109
    print_statement                shift and go to state 110
    while_statement                shift and go to state 111
    return_statement               shift and go to state 112

state 106

    (14) function -> FUNCTION IDENTIFIER ( identifier_list ) { function_statement_list . }
    (39) function_statement_list -> function_statement_list . ; function_statement

    }               shift and go to state 122
    ;               shift and go to state 123


state 107

    (38) function_statement_list -> function_statement .

    }               reduce using rule 38 (function_statement_list -> function_statement .)
    ;               reduce using rule 38 (function_statement_list -> function_statement .)


state 108

    (40) function_statement -> if_statement .

    }               reduce using rule 40 (function_statement -> if_statement .)
    ;               reduce using rule 40 (function_statement -> if_statement .)


state 109

    (41) function_statement -> assigment_statement .

    }               reduce using rule 41 (function_statement -> assigment_statement .)
    ;               reduce using rule 41 (function_statement -> assigment_statement .)


state 110

    (42) function_statement -> print_statement .

    }               reduce using rule 42 (function_statement -> print_statement .)
    ;               reduce using rule 42 (function_statement -> print_statement .)


state 111

    (43) function_statement -> while_statement .

    }               reduce using rule 43 (function_statement -> while_statement .)
    ;               reduce using rule 43 (function_statement -> while_statement .)


state 112

    (44) function_statement -> return_statement .

    }               reduce using rule 44 (function_statement -> return_statement .)
    ;               reduce using rule 44 (function_statement -> return_statement .)


state 113

    (45) return_statement -> RETURN . expression
    (48) expression -> . multiplication
    (49) expression -> . expression + multiplication
    (50) expression -> . expression - multiplication
    (51) multiplication -> . item
    (52) multiplication -> . multiplication * item
    (53) multiplication -> . multiplication / item
    (54) item -> . function_calling
    (55) item -> . IDENTIFIER
    (56) item -> . INT_N
    (57) item -> . FLOAT_N
    (58) item -> . ( expression )
    (16) function_calling -> . IDENTIFIER ( arguments )

    IDENTIFIER      shift and go to state 47
    INT_N           shift and go to state 53
    FLOAT_N         shift and go to state 54
    (               shift and go to state 55

    expression                     shift and go to state 124
    multiplication                 shift and go to state 50
    item                           shift and go to state 51
    function_calling               shift and go to state 52

state 114

    (22) argument -> ( expression . )
    (49) expression -> expression . + multiplication
    (50) expression -> expression . - multiplication

    )               shift and go to state 125
    +               shift and go to state 66
    -               shift and go to state 67


state 115

    (16) function_calling -> IDENTIFIER ( arguments ) .

    *               reduce using rule 16 (function_calling -> IDENTIFIER ( arguments ) .)
    /               reduce using rule 16 (function_calling -> IDENTIFIER ( arguments ) .)
    +               reduce using rule 16 (function_calling -> IDENTIFIER ( arguments ) .)
    -               reduce using rule 16 (function_calling -> IDENTIFIER ( arguments ) .)
    }               reduce using rule 16 (function_calling -> IDENTIFIER ( arguments ) .)
    ;               reduce using rule 16 (function_calling -> IDENTIFIER ( arguments ) .)
    )               reduce using rule 16 (function_calling -> IDENTIFIER ( arguments ) .)
    EQ_OP           reduce using rule 16 (function_calling -> IDENTIFIER ( arguments ) .)
    >               reduce using rule 16 (function_calling -> IDENTIFIER ( arguments ) .)
    <               reduce using rule 16 (function_calling -> IDENTIFIER ( arguments ) .)


state 116

    (18) arguments -> arguments , . argument
    (19) argument -> . IDENTIFIER
    (20) argument -> . INT_N
    (21) argument -> . FLOAT_N
    (22) argument -> . ( expression )

    IDENTIFIER      shift and go to state 88
    INT_N           shift and go to state 92
    FLOAT_N         shift and go to state 93
    (               shift and go to state 89

    argument                       shift and go to state 126

state 117

    (69) boolean -> ( expression EQ_OP expression ) .

    &               reduce using rule 69 (boolean -> ( expression EQ_OP expression ) .)
    |               reduce using rule 69 (boolean -> ( expression EQ_OP expression ) .)
    {               reduce using rule 69 (boolean -> ( expression EQ_OP expression ) .)


state 118

    (70) boolean -> ( expression > expression ) .

    &               reduce using rule 70 (boolean -> ( expression > expression ) .)
    |               reduce using rule 70 (boolean -> ( expression > expression ) .)
    {               reduce using rule 70 (boolean -> ( expression > expression ) .)


state 119

    (71) boolean -> ( expression < expression ) .

    &               reduce using rule 71 (boolean -> ( expression < expression ) .)
    |               reduce using rule 71 (boolean -> ( expression < expression ) .)
    {               reduce using rule 71 (boolean -> ( expression < expression ) .)


state 120

    (31) statement_list_if -> statement_list_if ; statement_if .

    }               reduce using rule 31 (statement_list_if -> statement_list_if ; statement_if .)
    ;               reduce using rule 31 (statement_list_if -> statement_list_if ; statement_if .)


state 121

    (15) function -> FUNCTION IDENTIFIER ( identifier_list ) { identifier_list function_statement_list . }
    (39) function_statement_list -> function_statement_list . ; function_statement

    }               shift and go to state 127
    ;               shift and go to state 123


state 122

    (14) function -> FUNCTION IDENTIFIER ( identifier_list ) { function_statement_list } .

    FUNCTION        reduce using rule 14 (function -> FUNCTION IDENTIFIER ( identifier_list ) { function_statement_list } .)
    INT             reduce using rule 14 (function -> FUNCTION IDENTIFIER ( identifier_list ) { function_statement_list } .)
    FLOAT           reduce using rule 14 (function -> FUNCTION IDENTIFIER ( identifier_list ) { function_statement_list } .)
    STRING          reduce using rule 14 (function -> FUNCTION IDENTIFIER ( identifier_list ) { function_statement_list } .)


state 123

    (39) function_statement_list -> function_statement_list ; . function_statement
    (40) function_statement -> . if_statement
    (41) function_statement -> . assigment_statement
    (42) function_statement -> . print_statement
    (43) function_statement -> . while_statement
    (44) function_statement -> . return_statement
    (61) if_statement -> . IF logical_expression { statement_list_if }
    (46) assigment_statement -> . IDENTIFIER = expression
    (47) assigment_statement -> . IDENTIFIER = STRING_LITERAL
    (59) print_statement -> . PRINT ( expression )
    (60) print_statement -> . PRINT ( STRING_LITERAL )
    (62) while_statement -> . WHILE logical_expression { statement_list }
    (45) return_statement -> . RETURN expression

    IF              shift and go to state 30
    IDENTIFIER      shift and go to state 27
    PRINT           shift and go to state 28
    WHILE           shift and go to state 29
    RETURN          shift and go to state 113

    function_statement             shift and go to state 128
    if_statement                   shift and go to state 108
    assigment_statement            shift and go to state 109
    print_statement                shift and go to state 110
    while_statement                shift and go to state 111
    return_statement               shift and go to state 112

state 124

    (45) return_statement -> RETURN expression .
    (49) expression -> expression . + multiplication
    (50) expression -> expression . - multiplication

    }               reduce using rule 45 (return_statement -> RETURN expression .)
    ;               reduce using rule 45 (return_statement -> RETURN expression .)
    +               shift and go to state 66
    -               shift and go to state 67


state 125

    (22) argument -> ( expression ) .

    )               reduce using rule 22 (argument -> ( expression ) .)
    ,               reduce using rule 22 (argument -> ( expression ) .)


state 126

    (18) arguments -> arguments , argument .

    )               reduce using rule 18 (arguments -> arguments , argument .)
    ,               reduce using rule 18 (arguments -> arguments , argument .)


state 127

    (15) function -> FUNCTION IDENTIFIER ( identifier_list ) { identifier_list function_statement_list } .

    FUNCTION        reduce using rule 15 (function -> FUNCTION IDENTIFIER ( identifier_list ) { identifier_list function_statement_list } .)
    INT             reduce using rule 15 (function -> FUNCTION IDENTIFIER ( identifier_list ) { identifier_list function_statement_list } .)
    FLOAT           reduce using rule 15 (function -> FUNCTION IDENTIFIER ( identifier_list ) { identifier_list function_statement_list } .)
    STRING          reduce using rule 15 (function -> FUNCTION IDENTIFIER ( identifier_list ) { identifier_list function_statement_list } .)


state 128

    (39) function_statement_list -> function_statement_list ; function_statement .

    }               reduce using rule 39 (function_statement_list -> function_statement_list ; function_statement .)
    ;               reduce using rule 39 (function_statement_list -> function_statement_list ; function_statement .)

